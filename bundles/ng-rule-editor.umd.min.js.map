{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/ng-rule-editor/src/lib/units.ts","../../../projects/ng-rule-editor/src/lib/rule-editor.service.ts","../../../projects/ng-rule-editor/src/lib/variable.ts","../../../projects/ng-rule-editor/src/lib/rule-editor.component.ts","../../../projects/ng-rule-editor/src/lib/variables/variables.component.ts","../../../projects/ng-rule-editor/src/lib/uneditable-variables/uneditable-variables.component.ts","../../../projects/ng-rule-editor/src/lib/question/question.component.ts","../../../projects/ng-rule-editor/src/lib/calculate-sum-prompt/calculate-sum-prompt.component.ts","../../../projects/ng-rule-editor/src/lib/math-to-fhirpath.pipe.ts","../../../projects/ng-rule-editor/src/lib/syntax-converter/syntax-converter.component.ts","../../../projects/ng-rule-editor/src/lib/syntax-preview/syntax-preview.component.ts","../../../projects/ng-rule-editor/src/lib/rule-editor.module.ts"],"names":["Object","create","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","UNIT_CONVERSION","kg","unit","factor","lbs","[in_i]","RuleEditorService","this","syntaxType","uneditableVariablesChange","Subject","variablesChange","questionsChange","mightBeScoreChange","finalExpressionChange","LANGUAGE_FHIRPATH","QUESTION_REGEX","VARIABLE_EXTENSION","CALCULATED_EXPRESSION","linkIdToQuestion","mightBeScore","variables","uneditableVariables","prototype","addVariable","existingNames","map","e","label","concat","name","push","getNewLabelName","type","expression","remove","splice","getUneditableVariables","fhir","Array","isArray","extension","reduce","accumulator","url","uneditableVariable","find","valueId","_a","filter","valueCode","join","description","_b","valueString","extractVariables","_this","variables_1","nonVariableExtensions_1","forEach","valueExpression","language","processVariable","itemHasScore","item","answerOption","some","isProbablyScore","linkIdContext","totalQuestions","scoreQuestions","linkId","import","resourceType","key","processItem","questions","hasOwnProperty","text","substring","getQuestionUnits","finalExpression","extractFinalExpression","items","items_1","items_1_1","extensionIndex","findIndex","matches","match","factor_1","variable","sourceUnits","conversion","toString","question","valueCoding","system","code","alphabet","split","firstLetterAlphabet","firstLetterAlphabet_1","firstLetterAlphabet_1_1","firstLetter","secondLetter","potentialName","alphabet_1","e_3","alphabet_1_1","toggleMightBeScore","export","JSON","parse","stringify","variablesToAdd","finalExpressionExtension","insertExtensions","addTotalScoreRule","exportSumOfScores","variableNames","scoreQuestionLinkIds","anyQuestionAnswered","sumString","totalCalculation","extensions","items_2","items_2_1","valueOrScoreExpression","convertible","toUnit","Injectable","args","providedIn","VariableType","RuleEditorComponent","variableService","fhirQuestionnaire","itemLinkId","submitButtonName","save","EventEmitter","advancedInterface","datePipe","DatePipe","suggestions","ngDestroy","calculateSumSubscription","unsubscribe","finalExpressionSubscription","variablesSubscription","ngOnChanges","reload","expressionSyntax","calculateSum","subscribe","fileInput","target","files","fileReader","FileReader","onload","result","input","console","error","readAsText","emit","downloadAsFile","data","fileName","blob","Blob","date","transform","Date","now","window","navigator","msSaveOrOpenBlob","URL","createObjectURL","a","document","createElement","setAttribute","href","download","click","revokeObjectURL","onSyntaxChange","$event","newSyntax","updateFinalExpression","Component","selector","template","Input","Output","VariablesComponent","ruleEditorService","variableType","levels","level","ngOnInit","variableSubscription","onAdd","onRemove","drop","event","moveItemInArray","previousIndex","currentIndex","getAvailableVariables","index","editableVariables","slice","UneditableVariablesComponent","uneditableVariablesSubscription","QuestionComponent","isNonConvertibleUnit","onChange","getQuestion","q","getConversionOptions","isQuestion","conversionOptions","CalculateSumPromptComponent","onCloseClick","onExportClick","MathToFhirpathPipe","undefined","fhirPath","mathToFhirpath","fhirconvert","Pipe","SyntaxConverterComponent","expressionChange","jsToFhirPathPipe","onExpressionChange","fhirPathExpression","SyntaxPreviewComponent","showWhenEmpty","NgModule","declarations","imports","FormsModule","BrowserAnimationsModule","DragDropModule","MatRadioModule","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","// Conversion table for simple units\nexport interface Unit {\n  unit: string;\n  factor: number;\n}\n\n// Supported unit conversions. Key is the \"from\" and value is the \"to\" array\nexport const UNIT_CONVERSION: { [key: string]: Unit[] } = {\n  kg: [{ unit: 'lbs', factor: 2.20462 }],\n  lbs: [{ unit: 'kg', factor: 0.453592 }],\n  '[in_i]': [{ unit: 'cm', factor: 2.54 }, { unit: 'm', factor: 0.0254 }]\n};\n","import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as mathToFhirpath from 'math-to-fhirpath';\n\nimport { Question, UneditableVariable, Variable } from './variable';\nimport { UNIT_CONVERSION } from './units';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RuleEditorService {\n  syntaxType = 'simple';\n  linkIdContext: string;\n  uneditableVariablesChange: Subject<UneditableVariable[]> =\n    new Subject<UneditableVariable[]>();\n  variablesChange: Subject<Variable[]> = new Subject<Variable[]>();\n  questionsChange: Subject<Question[]> = new Subject<Question[]>();\n  mightBeScoreChange: Subject<boolean> = new Subject<boolean>();\n  finalExpressionChange: Subject<string> = new Subject<string>();\n  uneditableVariables: UneditableVariable[];\n  variables: Variable[];\n  questions: Question[];\n  finalExpression: string;\n\n  private LANGUAGE_FHIRPATH = 'text/fhirpath';\n  private QUESTION_REGEX = /^%resource\\.item\\.where\\(linkId='(.*)'\\)\\.answer\\.value(?:\\*(\\d*\\.?\\d*))?$/;\n  private VARIABLE_EXTENSION = 'http://hl7.org/fhir/StructureDefinition/variable';\n  private CALCULATED_EXPRESSION = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression';\n\n  private linkIdToQuestion = {};\n  private fhir;\n  mightBeScore = false;\n\n  constructor() {\n    this.variables = [];\n    this.uneditableVariables = [];\n  }\n\n  /**\n   * Create a new variable\n   */\n  addVariable(): void {\n    // Get all the existing variable names\n    const existingNames = this.variables.map((e) => e.label)\n      .concat(this.uneditableVariables.map((e) => e.name));\n\n    this.variables.push({\n      label: this.getNewLabelName(existingNames),\n      type: 'question',\n      expression: ''\n    });\n    this.variablesChange.next(this.variables);\n  }\n\n  /**\n   * Remove a variable\n   * @param i - index of variable to remove\n   */\n  remove(i: number): void {\n    this.variables.splice(i, 1);\n  }\n\n  /**\n   * Get the list of uneditable variables based on the FHIR Questionnaire\n   * @param fhir - FHIR Questionnaire\n   */\n  getUneditableVariables(fhir): UneditableVariable[] {\n    const launchContextExtensionUrl = 'http://hl7.org/fhir/StructureDefinition/questionnaire-launchContext';\n\n    if (Array.isArray(fhir.extension)) {\n      return fhir.extension.reduce((accumulator, extension) => {\n        if (extension.url === launchContextExtensionUrl && extension.extension) {\n          const uneditableVariable = {\n            name: extension.extension.find((e) => e.url === 'name').valueId,\n            type: extension.extension.filter((e) => e.url === 'type')?.map((e) => e.valueCode).join('|'),\n            description: extension.extension.find((e) => e.url === 'description')?.valueString\n          };\n\n          accumulator.push(uneditableVariable);\n        }\n        return accumulator;\n      }, []);\n    }\n\n    return [];\n  }\n\n  /**\n   * Get and remove the variables from the FHIR object\n   * @param fhir\n   */\n  extractVariables(fhir): Variable[] {\n    // Look at the top level fhirpath related extensions to populate the editable variables\n    // TODO look at the focus item variables\n\n    if (fhir.extension) {\n      const variables = [];\n      const nonVariableExtensions = [];\n\n      fhir.extension.forEach((extension) => {\n        if (extension.url === this.VARIABLE_EXTENSION &&\n          extension.valueExpression && extension.valueExpression.language === this.LANGUAGE_FHIRPATH) {\n          variables.push(\n            this.processVariable(extension.valueExpression.name, extension.valueExpression.expression));\n        } else {\n          nonVariableExtensions.push(extension);\n        }\n      });\n\n      // Remove the variables so they can be re-added on export\n      fhir.extension = nonVariableExtensions;\n\n      return variables;\n    }\n\n    return [];\n  }\n\n  /**\n   * Check if the current item has an ordinalValue extension on the answer\n   * @param item - Question item or linkId\n   */\n  itemHasScore(item): boolean {\n    if (typeof item === 'string') {\n      item = this.linkIdToQuestion[item];\n    }\n\n    return (item.answerOption || []).some((answerOption) => {\n      return (answerOption.extension || []).some((extension) => {\n        return extension.url === 'http://hl7.org/fhir/StructureDefinition/ordinalValue';\n      });\n    });\n  }\n\n  // TODO check if this is already a score calculation\n  /**\n   * Look at the ordinalValue on the answers of all the questions and if over the threshold\n   * percentage of the items have it return true\n   * @param fhir - FHIR Questionnaire\n   * @param linkIdContext - linkId to exclude from calculation\n   */\n  isProbablyScore(fhir, linkIdContext): boolean {\n    const THRESHOLD = 0.6;  // Percent of questions (minus the one we're editing)\n    // which need to be scores to determine we want to sum them up\n\n    let totalQuestions = fhir.item.length;\n    let scoreQuestions = 0;\n\n    fhir.item.forEach((item) => {\n      if (item.linkId === linkIdContext) {\n        totalQuestions--;\n      } else if (this.itemHasScore(item)) {\n        scoreQuestions++;\n      }\n    });\n\n    return scoreQuestions / totalQuestions >= THRESHOLD;\n  }\n\n  /**\n   * Import a FHIR Questionnaire to populate questions\n   * @param fhir - FHIR Questionnaire\n   * @param linkIdContext - Context to use for final expression\n   */\n  import(fhir, linkIdContext?): void {\n    this.linkIdContext = linkIdContext;  // TODO change notification for linkId?\n    this.fhir = fhir;\n\n    if (fhir.resourceType === 'Questionnaire' && fhir.item && fhir.item.length) {\n      this.mightBeScore = this.isProbablyScore(fhir, linkIdContext);\n      this.mightBeScoreChange.next(this.mightBeScore);\n\n      this.uneditableVariables = this.getUneditableVariables(fhir);\n      this.uneditableVariablesChange.next(this.uneditableVariables);\n\n      this.linkIdToQuestion = {};\n      const linkIdToQuestion = this.linkIdToQuestion;\n      this.processItem(fhir.item);\n\n      this.variables = this.extractVariables(fhir);\n      this.variablesChange.next(this.variables);\n\n      this.questions = [];\n\n      // tslint:disable-next-line:forin\n      for (const key in linkIdToQuestion) {\n        if (!linkIdToQuestion.hasOwnProperty(key)) {\n          return;\n        }\n        const e = linkIdToQuestion[key];\n        // TODO decimal vs choice\n        const MAX_Q_LEN = 60;  // Maximum question length before truncating.\n\n        const text = e.text;\n\n        this.questions.push({\n          linkId: e.linkId,\n          text: text.length > MAX_Q_LEN ? text.substring(0, MAX_Q_LEN) + '...' : text,\n          unit: this.getQuestionUnits(e.linkId)\n        });\n      }\n      this.questionsChange.next(this.questions);\n\n      this.finalExpression = this.extractFinalExpression(fhir.item, linkIdContext);\n      this.finalExpressionChange.next(this.finalExpression);\n    }\n  }\n\n  /**\n   * Process nested FHIR Questionnaire items\n   * @param items - Current level of item nesting\n   * @private\n   */\n  private processItem(items): void {\n    items.forEach((e) => {\n      this.linkIdToQuestion[e.linkId] = e;\n      if (e.item) {\n        this.processItem(e.item);\n      }\n    });\n  }\n\n  /**\n   * Get and remove the final expression\n   * @param items\n   * @param linkId\n   */\n  extractFinalExpression(items, linkId): string {\n    for (const item of items) {\n      if (item.extension) {\n        const extensionIndex = item.extension.findIndex((e) => {\n          return e.url === this.CALCULATED_EXPRESSION && e.valueExpression.language === this.LANGUAGE_FHIRPATH &&\n            e.valueExpression.expression;\n        });\n\n        if (extensionIndex !== -1) {\n          const finalExpression = item.extension[extensionIndex].valueExpression.expression;\n          item.extension.splice(extensionIndex, 1);\n\n          return finalExpression;\n        }\n      } else if (item.item) {\n        return this.extractFinalExpression(item.item, linkId);\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Process the an expression into a possible question\n   * @param name - Name to assign variable\n   * @param expression - Expression to process\n   * @private\n   */\n  private processVariable(name, expression): Variable {\n    const matches = expression.match(this.QUESTION_REGEX);\n\n    if (matches !== null) {\n      const linkId = matches[1];\n      const factor = matches[2];\n\n      const variable: Variable = {\n        label: name,\n        type: 'question',\n        linkId,\n        expression\n      };\n\n      if (factor) {\n        // We might be able to do unit conversion\n        const sourceUnits = this.getQuestionUnits(linkId);\n\n        if (UNIT_CONVERSION.hasOwnProperty(sourceUnits)) {\n          const conversions = UNIT_CONVERSION[sourceUnits];\n          const conversion = conversions.find((e) => {\n            return e.factor.toString() === factor;\n          });\n\n          variable.unit = conversion.unit;\n        }\n      }\n\n      return variable;\n    } else {\n      return {\n        label: name,\n        type: 'expression',\n        expression\n      };\n    }\n  }\n\n  // TODO check behavior of repeating linkId\n  /**\n   * Get question units for the question\n   * @param linkId - Question linkId\n   * @private\n   */\n  private getQuestionUnits(linkId): string {\n    const QUESTIONNAIRE_UNIT = 'http://hl7.org/fhir/StructureDefinition/questionnaire-unit';\n    const question = this.linkIdToQuestion[linkId];\n\n    if (question.extension) {\n      const extension = question.extension.find((e) => {\n        return e.url === QUESTIONNAIRE_UNIT &&\n          e.valueCoding.system && e.valueCoding.system === 'http://unitsofmeasure.org';\n      });\n\n      if (extension && extension.valueCoding.code) {\n        return extension.valueCoding.code;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Generate a label name like A, B, C, ... AA, AB which is not already used\n   * @param existingNames {string[]} - Array of names already used by existing variables\n   * @private\n   */\n  private getNewLabelName(existingNames: string[]): string {\n    // All letters which can be used for a simple variable name\n    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n\n    // First pass is with a single character variable name. Other passes are with two\n    const firstLetterAlphabet = [''].concat(alphabet);\n    for (const firstLetter of firstLetterAlphabet) {\n      for (const secondLetter of alphabet) {\n        const potentialName = firstLetter + secondLetter;\n\n        const count = existingNames.filter((e) => e === potentialName);\n\n        if (count.length === 0) {\n          return potentialName;\n        }\n      }\n    }\n\n    // Don't return a suggested name if we exhausted all combinations\n    return '';\n  }\n\n  /**\n   * Toggle the mightBeScore\n   */\n  toggleMightBeScore(): void {\n    this.mightBeScore = !this.mightBeScore;\n    this.mightBeScoreChange.next(this.mightBeScore);\n  }\n\n  /**\n   * Add variables and finalExpression and return the new FHIR Questionnaire\n   * @param finalExpression\n   */\n  export(finalExpression: string): object {\n    // TODO support for different variable scopes\n    // Copy the fhir object so we can export more than once\n    // (if we add our data the second export will have duplicates)\n    const fhir = JSON.parse(JSON.stringify(this.fhir));\n\n    const variablesToAdd = this.variables.map((e) => {\n      return {\n        url: this.VARIABLE_EXTENSION,\n        valueExpression: {\n          name: e.label,\n          language: this.LANGUAGE_FHIRPATH,\n          expression: e.expression\n        }\n      };\n    });\n\n    if (fhir.extension) {\n      fhir.extension = fhir.extension.concat(variablesToAdd);\n    } else {\n      fhir.extension = variablesToAdd;\n    }\n\n    const finalExpressionExtension = {\n      url: this.CALCULATED_EXPRESSION,\n      valueExpression: {\n        language: this.LANGUAGE_FHIRPATH,\n        expression: finalExpression\n      }\n    };\n\n    this.insertExtensions(fhir.item, this.linkIdContext, [finalExpressionExtension]);\n\n    return fhir;\n  }\n\n\n  /**\n   * Takes FHIR questionnaire definition and a linkId and returns a new FHIR\n   * Questionnaire with a calculated expression at the given linkId which sums up\n   * all the ordinal values in the questionnaire\n   */\n  addTotalScoreRule(fhir, linkId): object {\n    this.fhir = fhir;\n    this.linkIdContext = linkId;\n    return this.exportSumOfScores();\n  }\n\n  /**\n   * Given the current FHIR questionnaire definition and a linkId return a new FHIR\n   * Questionnaire with a calculated expression at the given linkId which sums up\n   * all the ordinal values in the questionnaire\n   */\n  exportSumOfScores(): object {\n    const fhir = this.fhir;\n    const linkIdContext = this.linkIdContext;\n\n    const variableNames = [];\n    const scoreQuestionLinkIds = [];\n\n    // Get an array of linkIds for score questions\n    fhir.item.forEach((item) => {\n      if (item.linkId !== linkIdContext && this.itemHasScore(item)) {\n        scoreQuestionLinkIds.push(item.linkId);\n      }\n    });\n\n    // Get as many short suggested variable names as we have score questions\n    scoreQuestionLinkIds.forEach(() => {\n      variableNames.push(this.getNewLabelName(variableNames));\n    });\n\n    const scoreQuestions = scoreQuestionLinkIds.map((e, i) => {\n      return {\n        url: this.VARIABLE_EXTENSION,\n        valueExpression: {\n          name: variableNames[i],\n          language: this.LANGUAGE_FHIRPATH,\n          expression: `%questionnaire.item.where(linkId = '${e}').answerOption` +\n            `.where(valueCoding.code=%resource.item.where(linkId = '${e}').answer.valueCoding.code).extension` +\n            `.where(url='http://hl7.org/fhir/StructureDefinition/ordinalValue').value`\n        }\n      };\n    });\n\n    const anyQuestionAnswered = {\n      url: this.VARIABLE_EXTENSION,\n      valueExpression: {\n        name: 'any_questions_answered',\n        language: this.LANGUAGE_FHIRPATH,\n        expression: variableNames.map((e) => `%${e}.exists()`).join(' or ')\n      }\n    };\n\n    const sumString = variableNames.map((e) => `iif(%${e}.exists(), %${e}, 0)`).join(' + ');\n\n    const totalCalculation = {\n      url: this.CALCULATED_EXPRESSION,\n      valueExpression: {\n        description: 'Total score calculation',\n        language: this.LANGUAGE_FHIRPATH,\n        expression: `iif(%any_questions_answered, ${sumString}, {})`\n      }\n    };\n\n    scoreQuestions.push(anyQuestionAnswered);\n    // @ts-ignore\n    scoreQuestions.push(totalCalculation);\n\n    this.insertExtensions(fhir.item, linkIdContext, scoreQuestions);\n\n    return fhir;\n  }\n\n  private insertExtensions(items, linkId, extensions): void {\n    for (const item of items) {\n      if (item.linkId === linkId) {\n        if (item.extension) {\n          item.extension = item.extension.concat(extensions);\n        } else {\n          item.extension = extensions;\n        }\n        break;\n      } else if (item.item) {\n        this.insertExtensions(item.item, linkId, extensions);\n      }\n    }\n  }\n\n  /**\n   * Get the expression for a question\n   * @param linkId - Question linkId\n   * @param itemHasScore - Answer has an ordinalValue extension\n   * @param convertible - Units can be converted\n   * @param unit - Base units\n   * @param toUnit - Destination units\n   */\n  valueOrScoreExpression(linkId: string, itemHasScore: boolean, convertible: boolean, unit: string, toUnit: string): string {\n    if (itemHasScore) {\n      return `%questionnaire.item.where(linkId = '${linkId}').answerOption` +\n        `.where(valueCoding.code=%resource.item.where(linkId = '${linkId}').answer.valueCoding.code).extension` +\n        `.where(url='http://hl7.org/fhir/StructureDefinition/ordinalValue').value`;\n    } else if (convertible && unit && toUnit) {\n      const factor = UNIT_CONVERSION[unit].find((e) => e.unit === toUnit).factor;\n      return `%resource.item.where(linkId='${linkId}').answer.value*${factor}`;\n    } else {\n      return `%resource.item.where(linkId='${linkId}').answer.value`;\n    }\n  }\n}\n","export interface UneditableVariable {\n  name: string;\n  type?: string;\n  description?: string;\n}\n\nexport interface Variable {\n  label: string;\n  type: string;\n  expression: string;\n  simple?: string;\n  linkId?: string;\n  unit?: string;\n}\n\nexport interface Question {\n  linkId: string;\n  text: string;\n  itemHasScore?: boolean;\n  unit?: string;\n}\n\nexport enum VariableType {\n  question = 'Question',\n  expression = 'FHIRPath Expression',\n  simple = 'Simple Expression'\n}\n","import { DatePipe } from '@angular/common';\nimport { Component, EventEmitter, Input, OnChanges, Output } from '@angular/core';\nimport { MatRadioChange } from '@angular/material/radio';\n\nimport { RuleEditorService } from './rule-editor.service';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'lhc-rule-editor',\n  templateUrl: 'rule-editor.component.html',\n  styleUrls: ['rule-editor.component.css']\n})\nexport class RuleEditorComponent implements OnChanges {\n  @Input() fhirQuestionnaire = null;\n  @Input() itemLinkId = null;\n  @Input() submitButtonName = 'Submit';\n  @Input() titleName: string;\n  @Output() save = new EventEmitter<object>();\n\n  expressionSyntax: string;\n  advancedInterface = true;\n  finalExpression: string;\n  finalExpressionFhirPath: string;\n  linkIdContext: string;\n  datePipe = new DatePipe('en-US');\n  calculateSum: boolean;\n  suggestions = [];\n  variables: string[];\n\n  private calculateSumSubscription;\n  private finalExpressionSubscription;\n  private variablesSubscription;\n\n  constructor(private variableService: RuleEditorService) {}\n\n  /**\n   * Angular lifecycle hook called before the component is destroyed\n   */\n  ngDestroy(): void {\n    this.calculateSumSubscription.unsubscribe();\n    this.finalExpressionSubscription.unsubscribe();\n    this.variablesSubscription.unsubscribe();\n  }\n\n  /**\n   * Angular lifecycle hook called on input changes\n   */\n  ngOnChanges(): void {\n    this.reload();\n  }\n\n  /**\n   * Re-import fhir and context and show the form\n   */\n  reload(): void {\n    if (this.fhirQuestionnaire !== null && this.itemLinkId !== null) {\n      this.variableService.import(this.fhirQuestionnaire, this.itemLinkId);\n    }\n\n    this.linkIdContext = this.variableService.linkIdContext;\n    this.expressionSyntax = this.variableService.syntaxType;\n    this.calculateSum = this.variableService.mightBeScore;\n    this.calculateSumSubscription = this.variableService.mightBeScoreChange.subscribe((mightBeScore) => {\n      this.calculateSum = mightBeScore;\n    });\n    this.finalExpression = this.variableService.finalExpression;\n    this.finalExpressionSubscription = this.variableService.finalExpressionChange.subscribe((finalExpression) => {\n      this.finalExpression = finalExpression;\n    });\n    this.variables = this.variableService.variables.map(e => e.label);\n    this.variablesSubscription = this.variableService.variablesChange.subscribe((variables) => {\n      this.variables = variables.map(e => e.label);\n    });\n  }\n\n  /**\n   * Import uploaded data as a FHIR Questionnaire\n   * @param fileInput - Form file upload\n   */\n  import(fileInput): void {\n    if (fileInput.target.files && fileInput.target.files[0]) {\n      const fileReader = new FileReader();\n\n      fileReader.onload = (e) => {\n        if (typeof e.target.result === 'string') {\n          try {\n            const input = JSON.parse(e.target.result);\n\n            this.variableService.import(input, this.linkIdContext);\n          } catch (e) {\n            console.error('Could not parse file', e);\n          }\n        } else {\n          console.error('Could not read file');\n        }\n      };\n\n      fileReader.readAsText(fileInput.target.files[0]);\n    }\n    fileInput.target.value = '';\n  }\n\n  /**\n   * Export FHIR Questionnaire and download as a file\n   */\n  export(): void {\n    this.save.emit(this.variableService.export(this.finalExpression));\n  }\n\n  /**\n   * Export FHIR questionnaire file by summing all ordinal values\n   */\n  exportSumOfScores(): void {\n    this.save.emit(this.variableService.exportSumOfScores());\n  }\n\n  /**\n   * Download data as a file\n   * @param data - Object which will this function will call JSON.stringify on\n   * @param fileName - File name to download as\n   * @private\n   */\n  private downloadAsFile(data, fileName?): void {\n    const blob = new Blob([\n      JSON.stringify(data, null, 2)\n    ]);\n\n    const date = this.datePipe.transform(Date.now(), 'yyyyMMdd-hhmmss');\n\n    fileName = fileName ? fileName : `fhirpath-${date}.json`;\n\n    if (window.navigator && window.navigator.msSaveOrOpenBlob) {\n      window.navigator.msSaveOrOpenBlob(blob, fileName);\n    } else {\n      const url = window.URL.createObjectURL(blob);\n      const a = document.createElement('a');\n\n      a.setAttribute('style', 'display: none');\n      a.href = url;\n      a.download = fileName;\n      a.click();\n      window.URL.revokeObjectURL(url);\n      a.remove();\n    }\n  }\n\n  /**\n   * Called when the syntax type is changed to clean up expressions if the data cannot be converted\n   * @param $event - event from from the caller\n   */\n  onSyntaxChange($event: MatRadioChange): void {\n    const newSyntax = $event.value;\n\n    // Clear the existing expression if switching away from fhirpath\n    if (newSyntax === 'simple') {\n      this.finalExpression = '';\n    }\n\n    this.variableService.syntaxType = newSyntax;\n  }\n\n  /**\n   * Update the final expression\n   * @param expression\n   */\n  updateFinalExpression(expression): void {\n    this.finalExpression = expression;\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\n\nimport { Variable, VariableType } from '../variable';\nimport { CdkDragDrop, moveItemInArray, transferArrayItem } from '@angular/cdk/drag-drop';\nimport { RuleEditorService } from '../rule-editor.service';\n\n@Component({\n  selector: 'lhc-variables',\n  templateUrl: './variables.component.html',\n  styleUrls: ['./variables.component.css']\n})\nexport class VariablesComponent implements OnInit {\n  @Input() advancedInterface;\n  variableType = VariableType;\n  variableSubscription;\n  variables: Variable[];\n  levels = [{\n      level: 0,\n      name: 'Top Level Scope'\n    }\n  ];\n\n  constructor(private ruleEditorService: RuleEditorService) {}\n\n  /**\n   * Angular lifecycle hook called when the component is initialized\n   */\n  ngOnInit(): void {\n    this.variables = this.ruleEditorService.variables;\n    this.variableSubscription = this.ruleEditorService.variablesChange.subscribe((variables) => {\n      this.variables = variables;\n    });\n  }\n\n  /**\n   * Angular lifecycle hook called before the component is destroyed\n   */\n  ngDestroy(): void {\n    this.variableSubscription.unsubscribe();\n  }\n\n  /**\n   * Called when adding a new variable\n   */\n  onAdd(): void {\n    this.ruleEditorService.addVariable();\n  }\n\n  /**\n   * Remove a variable at an index\n   * @param i - index to remove\n   */\n  onRemove(i: number): void {\n    this.ruleEditorService.remove(i);\n  }\n\n  /**\n   * Drag and drop rearrange of variable order\n   * @param event - drag and drop event\n   */\n  drop(event: CdkDragDrop<Variable[]>): void {\n    moveItemInArray(this.variables, event.previousIndex, event.currentIndex);\n  }\n\n  /**\n   * Get the labels of available variables at the current index\n   * @param index - Index of variable we're editing\n   */\n  getAvailableVariables(index: number): Array<string> {\n    const uneditableVariables = this.ruleEditorService.uneditableVariables.map((e) => e.name);\n    // Only return variables up to but not including index\n    const editableVariables = this.variables.map((e) => e.label).slice(0, index);\n\n    return uneditableVariables.concat(editableVariables);\n  }\n}\n","import { Component, OnInit } from '@angular/core';\nimport { RuleEditorService } from '../rule-editor.service';\nimport { UneditableVariable } from '../variable';\n\n@Component({\n  selector: 'lhc-uneditable-variables',\n  templateUrl: './uneditable-variables.component.html'\n})\nexport class UneditableVariablesComponent implements OnInit {\n  uneditableVariables: UneditableVariable[];\n  uneditableVariablesSubscription;\n\n  constructor(private variableService: RuleEditorService) {}\n\n  /**\n   * Angular lifecycle hook called when the component is initialized\n   */\n  ngOnInit(): void {\n    this.uneditableVariables = this.variableService.uneditableVariables;\n    this.uneditableVariablesSubscription =\n        this.variableService.uneditableVariablesChange.subscribe((variables) => {\n      this.uneditableVariables = variables;\n    });\n  }\n\n  /**\n   * Angular lifecycle hook called before the component is destroyed\n   */\n  ngDestroy(): void {\n    this.uneditableVariablesSubscription.unsubscribe();\n  }\n}\n","import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';\nimport { Question } from '../variable';\nimport { RuleEditorService } from '../rule-editor.service';\nimport { Unit, UNIT_CONVERSION } from '../units';\n\n@Component({\n  selector: 'lhc-question',\n  templateUrl: './question.component.html'\n})\nexport class QuestionComponent implements OnInit {\n  @Input() variable;\n  @Input() advancedInterface;\n  linkId = '';\n  questions: Question[];\n  itemHasScore = false;\n  isNonConvertibleUnit = false;\n  toUnit: string;\n  unit: string;\n  conversionOptions: Unit[];\n\n  constructor(private variableService: RuleEditorService) {}\n\n  /**\n   * Angular lifecycle hook called when the component is initialized\n   */\n  ngOnInit(): void {\n    this.linkId = this.variable.linkId ? this.variable.linkId : '';\n    this.toUnit = this.variable.unit ? this.variable.unit : '';\n    this.questions = this.variableService.questions;\n\n    this.onChange(false);\n\n    this.variableService.questionsChange.subscribe((questions) => {\n      this.questions = questions;\n    });\n  }\n\n  /**\n   * Get the question based on linkId\n   * @param linkId - FHIR linkId\n   */\n  getQuestion(linkId): Question {\n    return this.questions.find((q) => {\n      return q.linkId === linkId;\n    });\n  }\n\n  /**\n   * Get the list of units we can convert to based on the starting unit\n   * @param unit - Starting unit\n   */\n  getConversionOptions(unit: string): Unit[] {\n    return UNIT_CONVERSION[unit];\n  }\n\n  /**\n   * Called when the questionnaire question or unit is changed\n   * @param isQuestion - The change was for a question\n   */\n  onChange(isQuestion): void {\n    if (isQuestion) {\n      // Reset the conversion options when the question changes\n      this.toUnit = '';\n    }\n\n    // If we already have a question selected (as opposed to the select... prompt)\n    if (this.linkId) {\n      const question = this.getQuestion(this.linkId);\n      this.unit = question?.unit;\n      this.conversionOptions = this.getConversionOptions(this.unit);\n      this.isNonConvertibleUnit = this.unit && !this.conversionOptions;\n\n      // Check if this is a score\n      if (!this.conversionOptions && !this.isNonConvertibleUnit) {\n        this.itemHasScore = this.variableService.itemHasScore(this.linkId);\n      } else {\n        this.itemHasScore = false;\n      }\n\n      this.variable.expression = this.variableService.valueOrScoreExpression(\n        this.linkId, this.itemHasScore, !this.isNonConvertibleUnit, this.unit, this.toUnit);\n    }\n  }\n}\n","import { Component, EventEmitter, OnInit, Output } from '@angular/core';\nimport { RuleEditorService } from '../rule-editor.service';\n\n@Component({\n  selector: 'lhc-calculate-sum-prompt',\n  templateUrl: './calculate-sum-prompt.component.html',\n  styleUrls: ['./calculate-sum-prompt.component.css']\n})\nexport class CalculateSumPromptComponent implements OnInit {\n  @Output() export: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(private ruleEditorService: RuleEditorService) { }\n\n  /**\n   * Angular lifecycle hook called when the component is initialized\n   */\n  ngOnInit(): void {}\n\n  /**\n   * Close the dialog by specifying this should not be a score calculation\n   */\n  onCloseClick(): void {\n    this.ruleEditorService.toggleMightBeScore();\n  }\n\n  /**\n   * Export the sum of scores as a FHIR Questionnaire\n   */\n  onExportClick(): void {\n    this.export.emit();\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport * as mathToFhirpath from 'math-to-fhirpath';\n\n@Pipe({\n  name: 'mathToFhirpath'\n})\nexport class MathToFhirpathPipe implements PipeTransform {\n\n  transform(value: string, variables: string[]): string {\n    if (value !== undefined) {\n      const fhirPath = mathToFhirpath.fhirconvert(value, variables);\n      if (fhirPath !== null) {\n        return fhirPath;\n      }\n    }\n\n    return 'Not valid';\n  }\n}\n","import { Component, Input, OnInit, Output, EventEmitter } from '@angular/core';\nimport { MathToFhirpathPipe } from '../math-to-fhirpath.pipe';\n\n@Component({\n  selector: 'lhc-syntax-converter',\n  templateUrl: './syntax-converter.component.html',\n  styleUrls: ['./syntax-converter.component.css']\n})\nexport class SyntaxConverterComponent implements OnInit {\n  @Input() value;\n  @Input() variables;\n  @Output() expressionChange = new EventEmitter<string>();\n\n  expression: string;\n  fhirPathExpression: string;\n  jsToFhirPathPipe = new MathToFhirpathPipe();\n\n  constructor() { }\n\n  ngOnInit(): void { }\n\n  onExpressionChange(value): void {\n    const fhirPath: string = this.jsToFhirPathPipe.transform(value, this.variables);\n    this.fhirPathExpression = fhirPath;\n\n    this.expressionChange.emit(fhirPath);\n  }\n\n}\n","import { Component, Input, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'lhc-syntax-preview',\n  templateUrl: './syntax-preview.component.html',\n  styleUrls: ['./syntax-preview.component.css']\n})\nexport class SyntaxPreviewComponent implements OnInit {\n  @Input() syntax;\n  @Input() showWhenEmpty = false;\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { RuleEditorComponent } from './rule-editor.component';\n\nimport { FormsModule } from '@angular/forms';\n\nimport { VariablesComponent } from './variables/variables.component';\nimport { UneditableVariablesComponent } from './uneditable-variables/uneditable-variables.component';\nimport { QuestionComponent } from './question/question.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport { CalculateSumPromptComponent } from './calculate-sum-prompt/calculate-sum-prompt.component';\nimport { MatRadioModule } from '@angular/material/radio';\nimport { MathToFhirpathPipe } from './math-to-fhirpath.pipe';\nimport { SyntaxConverterComponent } from './syntax-converter/syntax-converter.component';\nimport { SyntaxPreviewComponent } from './syntax-preview/syntax-preview.component';\n\n\n\n@NgModule({\n  declarations: [\n    RuleEditorComponent,\n    VariablesComponent,\n    UneditableVariablesComponent,\n    QuestionComponent,\n    CalculateSumPromptComponent,\n    MathToFhirpathPipe,\n    SyntaxConverterComponent,\n    SyntaxPreviewComponent\n  ],\n  imports: [\n    FormsModule,\n    BrowserAnimationsModule,\n    DragDropModule,\n    MatRadioModule\n  ],\n  exports: [\n    RuleEditorComponent\n  ]\n})\nexport class RuleEditorModule { }\n"]}