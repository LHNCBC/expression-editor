{"version":3,"file":"rule-editor.service.d.ts","sources":["rule-editor.service.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Subject } from 'rxjs';\nimport { Question, UneditableVariable, Variable } from './variable';\nexport interface SimpleStyle {\n    h1?: object;\n    h2?: object;\n    previewArea?: object;\n    variableHeader?: object;\n    variableRow?: object;\n    buttonPrimary?: object;\n    buttonSecondary?: object;\n    buttonDanger?: object;\n    input?: object;\n    select?: object;\n    description?: object;\n}\nexport declare class RuleEditorService {\n    syntaxType: string;\n    linkIdContext: string;\n    uneditableVariablesChange: Subject<UneditableVariable[]>;\n    variablesChange: Subject<Variable[]>;\n    questionsChange: Subject<Question[]>;\n    mightBeScoreChange: Subject<boolean>;\n    finalExpressionChange: Subject<string>;\n    disableAdvancedChange: Subject<boolean>;\n    uneditableVariables: UneditableVariable[];\n    variables: Variable[];\n    questions: Question[];\n    finalExpression: string;\n    simpleExpression: string;\n    caseStatements: boolean;\n    needsAdvancedInterface: boolean;\n    private LANGUAGE_FHIRPATH;\n    private LANGUAGE_FHIR_QUERY;\n    private QUESTION_REGEX;\n    private QUERY_REGEX;\n    private VARIABLE_EXTENSION;\n    private SCORE_VARIABLE_EXTENSION;\n    private SCORE_EXPRESSION_EXTENSION;\n    private SIMPLE_SYNTAX_EXTENSION;\n    private CALCULATED_EXPRESSION;\n    private LAUNCH_CONTEXT_URI;\n    private linkIdToQuestion;\n    private fhir;\n    mightBeScore: boolean;\n    constructor();\n    /**\n     * Create a new variable\n     */\n    addVariable(): void;\n    /**\n     * Remove a variable\n     * @param i - index of variable to remove\n     */\n    remove(i: number): void;\n    /**\n     * Trigger an update (used when changing variable names to update the preview)\n     */\n    update(): void;\n    /**\n     * Checks the advanced interface status and allows toggle if no expressions or\n     * queries are present\n     * @param toggleOn - Set the advanced interface on (without having to run checks)\n     */\n    checkAdvancedInterface(toggleOn?: boolean): void;\n    /**\n     * Get the list of uneditable variables based on the FHIR Questionnaire\n     * @param questionnaire - FHIR Questionnaire\n     */\n    getUneditableVariables(questionnaire: any): UneditableVariable[];\n    /**\n     * Get and remove the variables from the FHIR object\n     * @param questionnaire\n     */\n    extractVariables(questionnaire: any): Variable[];\n    /**\n     * Check if the current item has an ordinalValue extension on the answer\n     * @param item - Question item or linkId\n     */\n    itemHasScore(item: any): boolean;\n    /**\n     * Get the number of ordinalValue on the answers of the questions on the\n     * Questionnaire\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkIdContext - linkId to exclude from calculation\n     * @return number of score questions on the questionnaire\n     */\n    getScoreQuestionCount(questionnaire: any, linkIdContext: any): number;\n    /**\n     * Import a FHIR Questionnaire to populate questions\n     * @param expressionUri - URI of expression extension on linkIdContext question\n     *  to extract and modify\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkIdContext - Context to use for final expression\n     * @return true if load was successful\n     */\n    import(expressionUri: string, questionnaire: any, linkIdContext: any): boolean;\n    /**\n     * Process nested FHIR Questionnaire items\n     * @param items - Current level of item nesting\n     * @private\n     */\n    private processItem;\n    /**\n     * Get and remove the simple syntax if available. If not return null\n     * @param expression\n     */\n    extractSimpleSyntax(expression: any): string | null;\n    /**\n     * Get and remove the final expression\n     * @param expressionUri - Expression extension URL\n     * @param items - FHIR questionnaire item array\n     * @param linkId - linkId of question where to extract expression\n     */\n    extractExpression(expressionUri: any, items: any, linkId: any): object | null;\n    /**\n     * Process a FHIRPath expression into a more user friendly format if possible.\n     * If the format of the FHIRPath matches a format we can display with a\n     * question dropdown, etc show that. If not show the FHIRPath expression.\n     * @param name - Name to assign variable\n     * @param expression - Expression to process\n     * @param index - Original order in extension list\n     * @param extensions - Any additional extensions (for simple fhirpath etc)\n     * @return Variable type which can be used by the Rule Editor to show a\n     * question, expression etc\n     * @private\n     */\n    private processVariable;\n    /**\n     * Process a x-fhir-query expression into a more user friendly format if\n     * possible. Show a code autocomplete field if possible if not show the\n     * expression editing field.\n     * @param name - Name to assign variable\n     * @param expression - Expression to process\n     * @param index - Original order in extension list\n     * @return Variable type which can be used by the Rule Editor to show a\n     * question, expression etc\n     * @private\n     */\n    private processQueryVariable;\n    /**\n     * Get question units for the question\n     * @param linkId - Question linkId\n     * @private\n     */\n    private getQuestionUnits;\n    /**\n     * Generate a label name like A, B, C, ... AA, AB which is not already used\n     * @param existingNames {string[]} - Array of names already used by existing variables\n     * @private\n     */\n    private getNewLabelName;\n    /**\n     * Toggle the mightBeScore\n     */\n    toggleMightBeScore(): void;\n    /**\n     * Add variables and finalExpression and return the new FHIR Questionnaire\n     * @param url Extension URL to use for the expression\n     * @param finalExpression\n     */\n    export(url: string, finalExpression: string): object;\n    /**\n     * Takes FHIR questionnaire definition and a linkId and returns the FHIR\n     * Questionnaire with a calculated expression at the given linkId which sums up\n     * all the ordinal values in the questionnaire\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkId - Question linkId\n     */\n    addTotalScoreRule(questionnaire: any, linkId: any): object;\n    /**\n     * Given the current FHIR questionnaire definition and a linkId return a new FHIR\n     * Questionnaire with a calculated expression at the given linkId which sums up\n     * all the ordinal values in the questionnaire\n     */\n    addSumOfScores(): object;\n    /**\n     * Checks if the referenced Questionnaire item is a score calculation added by\n     * the Rule Editor\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkId - Questionnaire item Link ID to check\n     * @return True if the question at linkId is a score calculation created by\n     * the Rule Editor, false otherwise\n     */\n    isScoreCalculation(questionnaire: any, linkId: any): boolean;\n    /**\n     * Updates a FHIR questionnaire score calculation on the item identified by\n     * the linkId\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkId - Questionnaire item Link ID to update\n     * @return Questionnaire with updated calculation\n     */\n    updateScoreCalculation(questionnaire: any, linkId: any): object;\n    /**\n     * Removes score calculations added by the rule editor on the entire\n     * questionnaire or on a specific item\n     * @param questionnaire - FHIR Questionnaire\n     * @param linkId - Questionnaire item Link ID where to remove score. If empty\n     * try to remove scores from all items.\n     * @return Questionnaire without the score calculation variable and expression\n     */\n    removeSumOfScores(questionnaire: any, linkId?: any): object;\n    /**\n     * Returns true if the extension has an extension for calculating score false otherwise\n     * @param extension - FHIR Extension object\n     * @private\n     */\n    private isScoreExtension;\n    private insertExtensions;\n    /**\n     * Get the expression for a question\n     * @param linkId - Question linkId\n     * @param itemHasScore - Answer has an ordinalValue extension\n     * @param convertible - Units can be converted\n     * @param unit - Base units\n     * @param toUnit - Destination units\n     */\n    valueOrScoreExpression(linkId: string, itemHasScore: boolean, convertible: boolean, unit: string, toUnit: string): string;\n}\n"]}